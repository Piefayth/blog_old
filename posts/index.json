[{"meta":{"title":"RenderMeshV2 & Multiple Worlds","subtitle":"Let's Perform Surgery on the Player Loop","peek":"Initializing and updating default systems with custom update loops and multiple worlds.","image":"default","id":"ecs_render_multiworld"},"post":"_This article assumes a working knowledge of basic Unity ECS concepts. Just getting started? Have a look at the [Unity ECS Forums](https://forum.unity.com/forums/entity-component-system-and-c-job-system.147/) as well as the [ECS Samples](https://github.com/Unity-Technologies/EntityComponentSystemSamples)._\n\n_This article was written for version `0.0.27` of the Unity.Entities package._\n\n***\n\nAnyone who has been working with ECS for a while will tell you, you're regularly nursing your project back to health from a bad case of API churn. Most recently for me, I had to convert my project to use `RenderMeshV2`. Previously, I had a custom update loop where I had a client and server world each created with `new World()` and I manually updated every system. It's not the most ergonomic way to go about it, but it works and you're always certain what order your systems execute in. The old transform and render systems were easy to create and update manually, but I just couldn't get this approach working with `RenderMeshV2`.\n\nA little googling led me to the `DefaultWorldInitialization.Initialize` method. Using this to create your worlds creates all the default systems you'd find in a regular world. Systems like, say, `RenderMeshV2` or the `SimulationSystemGroup`. Great. Create the client world, create the server world, then just stick them in the update loop with `ScriptBehaviourUpdateOrder.UpdatePlayerLoop(params World[])`!\n\n\nOh. Well, that API was there the _last_ time I looked. The `World[]` signature of that method is gone now. It accepts a singular World, and passing two consecutive Worlds will remove the first.\n\nBut, admittedly, it's straightforward enough to create the worlds, snag the relevant systems from them, and update them from a `MonoBehaviour`. \n\n```c#\nClient client;\nServer server;\nPresentationSystemGroup clientRender;\nSimulationSystemGroup clientSim;\n\nvoid Awake() {\n    DefaultWorldInitialization.Initialize(\"Server World\", false);\n    server = World.Active.GetOrCreateManager<Server>();\n    DefaultWorldInitialization.Initialize(\"Client World\", false);\n    client = World.Active.GetOrCreateManager<Client>();\n    clientSim = World.Active.GetOrCreateManager<SimulationSystemGroup>();\n    clientRender = World.Active.GetOrCreateManager<PresentationSystemGroup>();\n}\n\nvoid Update() {\n    clientRender.Update();\n}\n\nvoid FixedUpdate() {\n    server.Update();\n    client.Update();\n    clientSim.Update();\n}\n```\n\nAdd an entity with `RenderMesh`, `LocalToWorld`, `Translation`, `Rotation`, and `NonUniformScale` to the client world, and it should draw as expected. \n\n![alt text](ecsRender1 \"My Cool Image\")\n\nEasy! \n\nWe've met the simple requirement of controlling our update loops individually while still having access to `RenderMeshV2`. This is great, but there are still some problems. Here's what I see.\n\n\n1. ALL the default systems are still running in the default world, and simply calling `.Dispose()` on it throws all kinds of errors. So does manually cleaning up the systems. We aren't using the default world, so let's put a stop to that.\n2. The presentation group is still running on the server. We won't be rendering anything there, so that's just wasting precious cycles. The server may or may not need the simulation group, depending on if you care about the results of the transform system.\n3. We are still updating from a `MonoBehaviour`.\n\nThe first problem is the simplest to solve. In fact, it's *exactly* the problem that `ICustomBootstrap` was invented to solve. The interface is simple.\n\n```c#\npublic class Bootstrap : ICustomBootstrap {\n    public List<Type> Initialize(List<Type> types) {\n        // When this is called, World.Active is the world being initialized\n        // The list of types returned will be the systems that are updated\n    }\n}\n```\n\nOur `Bootstrap` will be called on the default world initialization just by virtue of having the `ICustomBootstrap` interface. Given that, we can simply remove everything from the default world when it's initialized.\n\n```c#\nif (World.Active.Name == \"Default World\") {\n    return new List<Type>();\n}\n```\n\nIt stands to reason we can also remove the presentation layer from the server world here, and of course we can! But how do we know which systems are involved with the presentation layer? They're conveniently all tagged with `[UpdateInGroup(typeof(PresentationSystemGroup))]` and we can use that data to remove them.\n\n```\nif (World.Active.Name == \"Server World\") {\n    for (int ti = 0; ti < types.Count; ti++) {\n        var attrs = types[ti].GetCustomAttributes(false);\n        for (int i = 0; i < attrs.Length; i++) {\n            if (attrs[i].GetType() == typeof(UpdateInGroupAttribute)) {\n                UpdateInGroupAttribute group = (UpdateInGroupAttribute) attrs[i];\n                if (group.GroupType == typeof(PresentationSystemGroup)) {\n                    types.RemoveAt(ti);\n                    ti--;\n                }\n            }\n        }\n    }\n}\n\nreturn types;\n```\n\nNow that we have our custom bootstrap, we're mostly no longer bogged down by the fact we used the default world initialization. I'd still like to remove as much logic from the MonoBehaviour as possible. Furthermore, I noticed some of the Unity staff discussing moving the simulation and presentation groups to places like PreUpdate and LateUpdate. Are we able to leverage those internal update loops as well?\n\nEnter the new PlayerLoop API.\n\n```\nusing UnityEngine.Experimental.LowLevel;\nusing UnityEngine.Experimental.PlayerLoop;\n```\n\nI've yet to find complete documentation on this API, but it's easy to see what's inside. Some of the methods from ScriptBehaviourUpdateOrder look interesting.\n\n```\nPlayerLoopSystem playerLoopSystem = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;\nPlayerLoopSystem[] subsystems = playerLoopSystem.subSystemList;\n\nfor (int i = 0; i < subsystems.Length; i++) {\n    PlayerLoopSystem system = subsystems[i];\n    Debug.Log(system.type)\n}\n```\n\nThis outputs a list of systems like `PreUpdate, Update, LateUpdate, FixedUpdate`. Each of these are also of the type `PlayerLoopSystem`, so it stands to reason we can iterate the subsystems of each one. Inspecting the contents of each will lead you to some familiar ECS systems! So we're in the right place, we just need to manipulate the subsystem list of the update phase we would like to modify.\n\n```\nCustomUpdateSystem customUpdateSystem = new CustomUpdateSystem(new ComponentSystem[] { client, server });\n\nfor ...\n    if (systems[i].type == typeof(FixedUpdate)) {\n        PlayerLoopSystem fixedUpdateSystem = systems[i];\n    \n        List<PlayerLoopSystem> fixedUpdateSystems = new List<PlayerLoopSystem>(fixedUpdateSystem.subSystemList);\n        PlayerLoopSystem customPlayerLoop = new PlayerLoopSystem();\n        customPlayerLoop.type = typeof(CustomUpdateSystem);\n        customPlayerLoop.updateDelegate = customUpdateSystem.MyFixedUpdate;\n        fixedUpdateSystems.Add(customPlayerLoop);\n    \n        fixedUpdateSystem.subSystemList = fixedUpdateSystems.ToArray();\n        playerLoopSystem.subSystemList[i] = fixedUpdateSystem;\n    }\n}\n\nScriptBehaviourUpdateOrder.SetPlayerLoop(playerLoopSystem);\n```\n\nThe above code creates a new `PlayerLoopSystem` and configures it to use a user-defined type for its execution logic. Then it inserts the user defined `PlayerLoopSystem` into the `FixedUpdate` loop subsystems. Note that this change does NOT automatically propagate back to ScriptBehaviourUpdateOrder, so we must call `SetPlayerLoop` with our modified playerLoopSystem. But what's a \"`CustomUpdateSystem`\"?\n\nIt can be anything you want that can provide a delegate! In this case, I'm using the following:\n\n```\nclass CustomUpdateSystem {\n    List<ScriptBehaviourManager> systems;\n\n    public CustomUpdateSystem(params ScriptBehaviourManager[] systems) {\n        this.systems = new List<ScriptBehaviourManager>(systems);\n    }\n\n    public void MyFixedUpdate() {\n        foreach (ScriptBehaviourManager system in systems) {\n            system.Update();\n        }\n    }\n}\n```\n\nThis implementation is nothing more than a class that takes a list of systems when it's created and updates them when `MyFixedUpdate` is called. `MyFixedUpdate` will then update each system individually. Though I haven't tried, I assume this approach will work with any stage of the player loop.\n\nBe warned that everything in this article subverts the default Unity bootstrap, so in an actual game you must manage your own system update order. If you'd like to manage system update order programmatically, it may be useful to take advantage of making `ComponentSystemGroup`s, adding systems to them with `AddSystemToUpdateList()`, then updating the groups with `group.Update()`.\n\nWant something you can run? [Check out the project for this article here](https://github.com/Piefayth/ecs_render_multiworld).\n"}]